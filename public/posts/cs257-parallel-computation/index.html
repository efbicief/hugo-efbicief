<!DOCTYPE html>
<html><head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Parallel Computation - Felix B</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Flynn&rsquo;s taxonomy Single Data stream Multiple Data stream Single Instruction SISD: &ldquo;Regular&rdquo; processor SIMD: Vectorisation Single Data MISD: Uncommon - n-version programming MIMD: Distributed systems More detail below. Flynn&#39;s taxonomy MIMD Available as shared memory and distributed memory. Shared memory: Communicate via memory, easy to program. Distributed memory: Communication can be done between autonomous processors in software. Examples include Ethernet, Infiniband, etc. Communicates via message passing. Hardware interconnection structures allow processors to access memory and communicate with other processors." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Parallel Computation" />
<meta property="og:description" content="Flynn&rsquo;s taxonomy Single Data stream Multiple Data stream Single Instruction SISD: &ldquo;Regular&rdquo; processor SIMD: Vectorisation Single Data MISD: Uncommon - n-version programming MIMD: Distributed systems More detail below. Flynn&#39;s taxonomy MIMD Available as shared memory and distributed memory. Shared memory: Communicate via memory, easy to program. Distributed memory: Communication can be done between autonomous processors in software. Examples include Ethernet, Infiniband, etc. Communicates via message passing. Hardware interconnection structures allow processors to access memory and communicate with other processors." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://git.fbcf.xyz/posts/cs257-parallel-computation/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-07T06:30:43+01:00" />
<meta property="article:modified_time" content="2022-06-07T06:30:43+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Parallel Computation"/>
<meta name="twitter:description" content="Flynn&rsquo;s taxonomy Single Data stream Multiple Data stream Single Instruction SISD: &ldquo;Regular&rdquo; processor SIMD: Vectorisation Single Data MISD: Uncommon - n-version programming MIMD: Distributed systems More detail below. Flynn&#39;s taxonomy MIMD Available as shared memory and distributed memory. Shared memory: Communicate via memory, easy to program. Distributed memory: Communication can be done between autonomous processors in software. Examples include Ethernet, Infiniband, etc. Communicates via message passing. Hardware interconnection structures allow processors to access memory and communicate with other processors."/>
<script src="https://git.fbcf.xyz/js/feather.min.js"></script>
	
	
        <link href="https://git.fbcf.xyz/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://git.fbcf.xyz/css/main.46ba03325b5087e4bf8af8478b7cbcd704d0bbc30a81b70daa3b1f89234d557a.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://git.fbcf.xyz/css/dark.beec145b83af0d77445953d9c13ffa0b82ce322075bcd619e86b6afcafc1426f.css"  disabled />
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://git.fbcf.xyz/">Felix B</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/tags/project">Projects</a>
		
		<a href="/tags/blog">Blog Posts</a>
		
		<a href="/tags/index">Notes</a>
		
		<a href="/posts">All posts</a>
		
		<a href="/tags">All Tags</a>
		
		| <a id="dark-mode-toggle" onclick="toggleTheme()" href=""></a>
		<script src="https://git.fbcf.xyz/js/themetoggle.js"></script>
		
	</nav>
	
</header>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
    integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"
    integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4"
    crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
    integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<main>
	<article>
		<div class="title">
			<h1 class="title">Parallel Computation</h1>
			<div class="meta">Posted on Jun 7, 2022
				
				
				
			</div>
		</div>

		

		<section class="body">
			<h1 id="flynns-taxonomy">Flynn&rsquo;s taxonomy</h1>
<table>
<thead>
<tr>
<th></th>
<th>Single Data stream</th>
<th>Multiple Data stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single Instruction</td>
<td>SISD: &ldquo;Regular&rdquo; processor</td>
<td>SIMD: Vectorisation</td>
</tr>
<tr>
<td>Single Data</td>
<td>MISD: Uncommon - n-version programming</td>
<td>MIMD: Distributed systems</td>
</tr>
</tbody>
</table>
<p>More detail below.
<figure><img src="/flynn.png" height="350"/><figcaption>
            <h4>Flynn&#39;s taxonomy</h4>
        </figcaption>
</figure>
</p>
<h2 id="mimd">MIMD</h2>
<ul>
<li>Available as shared memory and distributed memory.</li>
<li>Shared memory: Communicate via memory, easy to program.
<ul>
<li>Distributed memory: Communication can be done between autonomous processors in software. Examples include Ethernet, Infiniband, etc. Communicates via message passing.</li>
</ul>
</li>
<li>Hardware interconnection structures allow processors to access memory and communicate with other processors.</li>
</ul>
<h1 id="hardware-interconnection">Hardware interconnection</h1>
<ul>
<li>Shared bus: Limited bandwidth, single point of failure, hard to resolve contention for resource.</li>
</ul>
<figure><img src="/bus.png" height="200"/><figcaption>
            <h4>Shared Bus</h4>
        </figcaption>
</figure>

<ul>
<li>Cross bar switch matrix: High bandwidth, good reliability, but still contention for same memory. Physically large and costly.</li>
</ul>
<figure><img src="/grid.png" height="200"/><figcaption>
            <h4>Cross bar switch matrix</h4>
        </figcaption>
</figure>

<ul>
<li>Static (dedicated links): the more links, the greater the interprocessor communication rate.</li>
</ul>
<figure><img src="/links.png" height="300"/><figcaption>
            <h4>Static structures</h4>
        </figcaption>
</figure>

<table>
<thead>
<tr>
<th>Structure</th>
<th># of connections</th>
<th># links per node</th>
<th>Max internode distance</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear array</td>
<td>$$n-1$$</td>
<td>$$2$$</td>
<td>$$n-1$$</td>
</tr>
<tr>
<td>Mesh: size $$\sqrt{n}\times\sqrt{n}$$</td>
<td>$$2(n-\sqrt{n})$$</td>
<td>$$4$$</td>
<td>$$2(\sqrt{n}-1)$$</td>
</tr>
<tr>
<td>Ring</td>
<td>$$n$$</td>
<td>$$2$$</td>
<td>$$\frac{n}{2}$$</td>
</tr>
<tr>
<td>Star</td>
<td>$$n-1$$</td>
<td>$$n-1$$</td>
<td>$$2$$</td>
</tr>
<tr>
<td>Hypercube: size $$n=2^k$$</td>
<td>$$\frac{n}{2}\log_{2}{n}$$</td>
<td>$$\log_{2}{n}$$</td>
<td>$$\log_{2}{n}$$</td>
</tr>
<tr>
<td>Complete connection</td>
<td>$$\frac{n(n-1)}{2}$$</td>
<td>$$n-1$$</td>
<td>$$1$$</td>
</tr>
</tbody>
</table>
<ul>
<li>Multistage switching networks: ALl processors connected to all other processors, and all requests non blocking. CLOS (Multistage cross bar switches) were originally made for telephone exchanges.
<ul>
<li>Uses 3 or more &lsquo;stages&rsquo;, where processor in a stage are connected to all others in the preceeding and succeeding stages. Non blocking and smaller than a cross bar switch matrix.</li>
<li>2 elements in each stage is a Benes network</li>
<li>Cell based networks: single bit control for data path i.e. each cell has 2 connections. Can be highly blocking, but needs fewer switches.</li>
<li>Baseline: uses &lsquo;self-routing&rsquo;, take one path for 0, one path for 1 (see below).</li>
</ul>
</li>
</ul>
<figure><img src="/baseband.png" height="250"/><figcaption>
            <h4>Baseline Network</h4>
        </figcaption>
</figure>

<h1 id="cache-coherence">Cache coherence</h1>
<p>In MIMD shared memory systems, we need to keep cache coherency over all autonomous processors. There are many ways to solve this:</p>
<ul>
<li>Shared caches: this has poor performance.</li>
<li>Non-cachable items: can cause problems!</li>
<li>Broadcast write: All cache writes are also sent to other caches. Copies in other caches are updated (slower) or invalidated (faster, but requires a fetch if needed by other processor).</li>
<li>Snoop bus: Write through, bus watcher checks for main memory writes on bus. If so, it invalidates it&rsquo;s local copy of the data written.</li>
<li>Directory methods: Lists of cached copies of data.
<ul>
<li>Full directory: Pointer bit for each processor, + dirty bit. Pointer set if that processor has a copy. Valid bit and private bit with data in cache - valid if data is up to date, private set if processor can write to it.</li>
<li>Limited directory: Only a fixed number of processors can have a copy of a piece of data. Directory therefore smaller.</li>
<li>Chained directory: Linked lists hold dictionary entries. Every entry in a cache points to another copy somewhere else.</li>
</ul>
</li>
<li>MESI protocol: Snoop bus with write back policy instead. Each cache line can be in 1 of 4 states:
<ul>
<li>Modified: Cache entry valid, main memory copy invalid, no copies exist.</li>
<li>Exclusive: No other cache holds the data, main memory up to date.</li>
<li>Shared: Other caches also hold the data, main memory up to date.</li>
<li>Invalid: Cache data invalid.</li>
<li>All cache lines start as invalid. When one fetches, it sets exclusive. When another fetches the same, it knows another cache has a copy from snooping, so sets shared, and so does the first cache.</li>
<li>Before a cache is written to, an invalidate signal is put on the bus, telling other caches to mark their copy invalid.</li>
<li>Exclusive correct copy is only written back to main memory when another CPU requests that data.</li>
<li>On a cache miss, Read with intent to modify (RWITM) routine happens - owner of the data writes it to memory.</li>
</ul>
</li>
</ul>
<h1 id="data-level-parallelism">Data level parallelism</h1>
<p>SIMD variations:</p>
<h2 id="vector-architecture">Vector architecture</h2>
<ul>
<li>Easy to compile for, reduces fetch bandwidth needed since less instructions to fetch.</li>
<li>Vector units are pipelined, scalar registers used to compute addresses to pass to vector unit.</li>
<li>Specialised vector load / store unit used to load to and from vector units.</li>
</ul>
<p>3 factors contribute to vector execution time: Length of vector operand, structural hazards and data dependency.</p>
<ul>
<li>Convoys: set of vector instructions that can potentially execute together. Number of convoys a good measure of performance.</li>
<li>Chaining: Vector operation can start as soon as elements of vector source become available.</li>
<li>Chime: unit of time to execute a single convoy.</li>
</ul>
<p>Vector architecture optimisation techniques:</p>
<ul>
<li>Multiple lanes: i.e. pipelining combined operations</li>
<li>Vector length registers: lets us optimise sections with less data than max. vector length (MVL)</li>
<li>Mask registers: Provides conditional execution for each vector element</li>
<li>Memory banking: to speed up vector initiation rate</li>
</ul>
<h2 id="gpus">GPUs</h2>
<ul>
<li>GPU parallelism unified as CUDA thread</li>
<li>CUDA threads organised into blocks of up to 512, whole blocks get executed at once</li>
</ul>
<h1 id="multithreading">Multithreading</h1>
<ul>
<li>MIPS = frequency (MHz) * Instructions per second.</li>
<li>Instruction stream divided so threads can execute in parallel.</li>
<li>Explicit multithreading: Interleaving explicitly different threads into the same pipeline / on parallel pipelines.</li>
<li>Implicit multithreading: Extracting multiple threads from the same program.
<ul>
<li>Interleaved/fine grain: Switch between each thread each cycle.</li>
<li>Block/coarse grain: Only switch when one thread causes a delay.</li>
<li>Simultaneous multithreading: using multiple execution units.</li>
<li>Chip multiprocessing: each core handles a thread.</li>
</ul>
</li>
</ul>
<h1 id="multicore">Multicore</h1>
<ul>
<li>Cores may or may not share different levels of cache .</li>
<li>Shared cache advantages: Constructive inference can reduce miss rates, Data shared by cores need not be replicated, can dynamically allocate cache space to each thread, interprocessor communication easy with shared memory, Cache coherence problem reduced.</li>
</ul>
<h1 id="clusters">Clusters</h1>
<ul>
<li>Group of &rsquo;node&rsquo; computers pretending to be one computer.</li>
<li>Uniform memory acces (UMA): All processors can access all parts of memory, and at the same rates.</li>
<li>Non-UMA (NUMA): All processors can access all parts of memory, but some processsors can access some patrts of memory faster / slower than others</li>
<li>Clusters scale very well.</li>
<li>Cache coherent NUMA (CC-NUMA): Maintains a transparant system wide memory whilst permitting individual nodes, usually using a directory method.</li>
</ul>
<h1 id="thread-level-parallelism">Thread level parallelism:</h1>
<ul>
<li>Instruction pairing: Link 2 instructions, get a result telling you if there was a context switch between their execution.</li>
<li>Gives safety to fetch and increment instructions eg. x+=1.</li>
<li>Memory consistency: If write invalidates are delayed, branches relying on values processed in other threads may be incorrect. We need sequential consistency.</li>
<li>Sequential consistency can hurt performance; we can use latency hiding techniques and relaxed consistency models to help this.</li>
</ul>
<h2 id="relaxed-consistency-models">Relaxed consistency models</h2>
<p>A -&gt; B denotes A must be completed before B. We have 4 sets of constraints we can relax:</p>
<ul>
<li>W-&gt;R: Total store ordering model, retains ordering of writes.</li>
<li>W-&gt;W: Partial order store model - impractical for most programs.</li>
<li>R-&gt;R and R/W: Variety of models incl. weak ordering and release consistency, depending on how synchronisation enforces orderings.</li>
</ul>
<figure><img src="/orderings.png" height="350"/><figcaption>
            <h4>Relaxed consistency models</h4>
        </figcaption>
</figure>

<p><a href="/posts/cs257-index/">All topics ⟶</a></p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					<li>
						
						<a href="/tags/cs257">CS257</a>
						
						<a href="/tags/architecture">Architecture</a>
						
						<a href="/tags/parallelism">Parallelism</a>
						
						<a href="/tags/notes">Notes</a>
						
					</li>
				</ul>
			</nav>
			
			
		</div>

		

	</article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/efbicief" title="GitHub"><i data-feather="github"></i></a>
    <a class="border"></a></div>
  <div class="footer-info">
    2023  © Felix B |  <a
      href="https://github.com/efbicief/archie-efbicief">Archie Theme</a> (fork) | Made with ❤️ using <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


<script>
  feather.replace()
</script></div>
    </body>
</html>
